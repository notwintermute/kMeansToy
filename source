import pygame
import math
import random

pygame.init()
# initializing the font
font = pygame.font.SysFont('calibri', 20)

# useful variable
pi = math.pi

# display resolution, right is used for UI
UI = 402
squareRes = 700
resX = squareRes
resY = squareRes

radius = 1  # radius of each dot
rnge = 1000  # range that the data takes (sharpness basically)
dSize = 5000  # number of dots
data = []  # this is where the data (position of each point) are stored
centroids = []  # this is where the positions of the centroids are stored
noK = 1  # number of centroids
centDist = []  # this is where the distance of each point to each centroid is stored
for i in range(dSize):
    centDist.append([])

centBel = []  # this is where 'which centroid does each point belong to' is stored
familySize = []  # this is where the number of points belonging to a centroid is stored
for i in range(noK):
    familySize.append(0)

colors = []  # this is where colors are stored
minB = 80  # minimum brightness for colors
trails = True  # trails on/off
centHist = []  # keeps track of the history of the centroids for trails
for x in range(noK):
    centHist.append([])
steps = 0  # number of steps
stepsT = 0  # number of steps in this trail
drawMode = 0  # mouse mode
Rad = 15  # brush radius
brushDen = 5  # brush density
drawing = False
erasing = False
mouseDist = []  # distance of centroids to mouse


# randomly picks a set of three numbers where one has to be over minB
def randBright():
    notbright = True
    pick = 0
    while notbright:
        pick = (random.randrange(255), random.randrange(255), random.randrange(255))
        if max(pick) > minB:
            notbright = False
    return pick


# distance function
def distance(a, m):
    return math.sqrt((a[0] - m[0]) ** 2 + (a[1] - m[1]) ** 2)


# add the values of lists with 2 elements
def addL(z, y):
    return [z[0] + y[0], z[1] + y[1]]


# generates random colors
def genRandColors(k, clrs):
    for z in range(k):
        clrs.append(randBright())


# generates random data
def genRandData(datasize, rng, dta):
    for y in range(datasize):
        dta.append([resX * (random.randrange(rng) / rng), resY * (random.randrange(rng) / rng)])


# initializes the centroids to random points
def initkMeans(dta, k, cen, datasize):
    for m in range(k):
        idx = random.randrange(datasize)
        cen.append(dta[idx])


# Assigns the distances from each point to every centroid and then assigns belonging
def kMeansAssignCentroids(dta, k, cen, cD, cB, dS):
    for z in range(dS):
        for y in range(k):
            cD[z].append(distance(cen[y], dta[z]))
    for z in cD:
        cB.append(z.index(min(z)))


# updates the position of each centroid to the average of their family

def kMeansUpdateCentroids(dta, k, cen, cB, dS, fS):
    for n, h in enumerate(cen):
        hold = (h[0], h[1])
        centHist[n].append(hold)
    sumhold = []
    dataconv = []
    for c in dta:
        dataconv.append([c[0] - resX / 2, c[1] - resY / 2])
    for h in range(k):
        sumhold.append([0, 0])
    # counting the number of points belonging to each centroid
    for h in cB:
        fS[h] += 1
    for h in range(dS):
        sumhold[cB[h]] = addL(sumhold[cB[h]], dataconv[h])
    for h in range(k):
        if not fS[h] == 0:
            cen[h] = [sumhold[h][0] / fS[h] + resX / 2, sumhold[h][1] / fS[h] + resY / 2]


genRandColors(noK, colors)
genRandData(dSize, rnge, data)
initkMeans(data, noK, centroids, dSize)
kMeansAssignCentroids(data, noK, centroids, centDist, centBel, dSize)

# initialize surface and start the main loop
surface = pygame.display.set_mode((resX + UI, resY))
running = True
while running:
    mouse = pygame.mouse.get_pos()
    if drawing:
        steps = 0
        for x in range(brushDen):
            randAng = (2 * pi) * (random.randrange(50) / 50)
            randRad = random.randrange(Rad)
            data.append([mouse[0] + randRad * math.cos(randAng), mouse[1] + randRad * math.sin(randAng)])
            dSize += 1
        centDist = []
        for i in range(dSize):
            centDist.append([])
        centBel = []
        familySize = []
        for i in range(noK):
            familySize.append(0)
        kMeansAssignCentroids(data, noK, centroids, centDist, centBel, dSize)

    if erasing:
        steps = 0
        for p in data:
            if distance(p, mouse) < Rad:
                data.pop(data.index(p))
                dSize -= 1
        centDist = []
        for i in range(dSize):
            centDist.append([])
        centBel = []
        familySize = []
        for i in range(noK):
            familySize.append(0)
        kMeansAssignCentroids(data, noK, centroids, centDist, centBel, dSize)

    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            running = False
        if event.type == pygame.MOUSEBUTTONDOWN:
            if not drawMode:
                if event.button == 1:
                    steps = 0
                    noK += 1
                    centroids.append(mouse)
                    familySize.append(0)
                    colors.append(randBright())
                    centDist = []
                    for x in range(dSize):
                        centDist.append([])
                    centBel = []
                    centHist = []
                    for x in range(noK):
                        centHist.append([])
                    kMeansAssignCentroids(data, noK, centroids, centDist, centBel, dSize)
                if event.button == 3 and noK > 1:
                    steps = 0
                    mouseDist = []
                    for p in centroids:
                        mouseDist.append(distance(p, mouse))
                    minDist = min(mouseDist)
                    closest = mouseDist.index(minDist)
                    noK -= 1
                    centroids.pop(closest)
                    familySize.pop(closest)
                    colors.pop(closest)
                    centDist = []
                    centHist = [[]]
                    for x in range(noK):
                        centHist.append([])
                    for x in range(dSize):
                        centDist.append([])
                    centBel = []
                    kMeansAssignCentroids(data, noK, centroids, centDist, centBel, dSize)
            if drawMode:
                steps = 0
                if event.button == 1:
                    drawing = True
                if event.button == 3:
                    erasing = True
        if event.type == pygame.MOUSEBUTTONUP:
            drawing = False
            erasing = False

        if event.type == pygame.KEYDOWN:
            if event.key == pygame.K_g:  # generate random data
                data = []
                colors = []
                centroids = []
                centHist = []
                for x in range(noK):
                    centHist.append([])
                centDist = []
                steps = 0
                stepsT = 0
                for x in range(dSize):
                    centDist.append([])
                centBel = []
                genRandColors(noK, colors)
                genRandData(dSize, rnge, data)
                initkMeans(data, noK, centroids, dSize)
                kMeansAssignCentroids(data, noK, centroids, centDist, centBel, dSize)

            if event.key == pygame.K_s:  # take step with k means
                kMeansUpdateCentroids(data, noK, centroids, centBel, dSize, familySize)
                centDist = []
                steps += 1
                stepsT += 1
                for i in range(dSize):
                    centDist.append([])
                centBel = []
                familySize = []
                for i in range(noK):
                    familySize.append(0)
                kMeansAssignCentroids(data, noK, centroids, centDist, centBel, dSize)

            if event.key == pygame.K_q and dSize > 0:  # increase number of clusters
                steps = 0
                noK += 1
                ind = random.randrange(dSize)
                centroids.append(data[ind])
                familySize.append(0)
                colors.append(randBright())
                centDist = []
                for x in range(dSize):
                    centDist.append([])
                centBel = []
                centHist = []
                for x in range(noK):
                    centHist.append([])
                kMeansAssignCentroids(data, noK, centroids, centDist, centBel, dSize)
            if event.key == pygame.K_a and noK > 1:  # decrease number of clusters
                steps = 0
                noK -= 1
                centroids.pop(-1)
                familySize.pop(-1)
                colors.pop(-1)
                centDist = []
                centHist = [[]]
                for x in range(noK):
                    centHist.append([])
                for x in range(dSize):
                    centDist.append([])
                centBel = []
                kMeansAssignCentroids(data, noK, centroids, centDist, centBel, dSize)
            if event.key == pygame.K_t:  # toggle trails
                if trails:
                    trails = False
                    centHist = [[]]
                    for x in range(noK):
                        centHist.append([])
                else:
                    trails = True
            if event.key == pygame.K_x:  # toggle draw mode
                if drawMode < 1:
                    drawMode += 1
                else:
                    drawMode = 0
            if event.key == pygame.K_c:  # change the color of the nearest centroid or clear the data lol
                if drawMode:
                    steps = 0
                    stepsT = 0
                    dSize = 0
                    noK = 1
                    data = []
                    colors = [(255, 255, 255)]
                    centroids = [[0, 0]]
                    centHist = []
                    for x in range(noK):
                        centHist.append([])
                    centDist = []
                    steps = 0
                    stepsT = 0
                    for x in range(dSize):
                        centDist.append([])
                    centBel = []
                else:
                    mouseDist = []
                    for p in centroids:
                        mouseDist.append(distance(p, mouse))
                    minDist = min(mouseDist)
                    closest = mouseDist.index(minDist)
                    colors[closest] = randBright()
            if drawMode:
                if event.key == pygame.K_e:
                    Rad += 2
                if event.key == pygame.K_d and Rad > 3:
                    Rad -= 2
                if event.key == pygame.K_r:
                    brushDen += 2
                if event.key == pygame.K_f and brushDen > 3:
                    brushDen -= 2
            if event.key == pygame.K_w:  # randomly assign centroids
                centroids = []
                centHist = []
                for x in range(noK):
                    centHist.append([])
                centDist = []
                steps = 0
                stepsT = 0
                for x in range(dSize):
                    centDist.append([])
                centBel = []
                initkMeans(data, noK, centroids, dSize)
                kMeansAssignCentroids(data, noK, centroids, centDist, centBel, dSize)

    surface.fill((0, 0, 0))

    for i in range(dSize):
        try:
            pygame.draw.circle(surface, colors[centBel[i]], data[i], radius)
        except IndexError:
            break

    if trails:
        noLines = 0
        for i, v in enumerate(centHist):
            for b in range(len(v) - 1):
                pygame.draw.line(surface, (255, 255, 255), v[b], v[b + 1], 2)
            try:
                pygame.draw.line(surface, (255, 255, 255), v[-1], centroids[i], 2)
            except IndexError:
                break

    if dSize > 0:
        for i in range(noK):
            try:
                pygame.draw.rect(surface, colors[i], (centroids[i][0] - 5, centroids[i][1] - 5, 10, 10))
                pygame.draw.rect(surface, (255, 255, 255), (centroids[i][0] - 5, centroids[i][1] - 5, 10, 10), width=1)
            except IndexError:
                break

    mouseDist = []
    if not drawMode:
        for p in centroids:
            mouseDist.append(distance(p, mouse))
        minDist = min(mouseDist)
        closest = mouseDist.index(minDist)
        pygame.draw.circle(surface, (255, 255, 255), centroids[closest], 15, width=3)
    if drawMode:
        for p in data:
            if distance(p, mouse) < Rad:
                pygame.draw.circle(surface, (255, 255, 255), p, radius)
        pygame.draw.circle(surface, (255, 255, 255), mouse, Rad, width=1)

    pygame.draw.line(surface, (255, 255, 255), (resX, 0), (resX, resY), 2)  # white line that divides points from UI

    t = 10  # distance of text from top
    s = 25  # separation between text (the variable makes it easier on me)
    UItext = [
             ["G to generate random data.",
              "S to take a step of k-means.",
              "Q to randomly add another cluster.",
              "A to delete most recent cluster.",
              "W to randomly assign centroids.",
              "T to toggle trails.",
              "X to toggle draw mode."],
             ["Draw Mode",
              "Left click to draw data.",
              "Right click to remove data.",
              "C to clear all data.",
              "E/D to increase/decrease brush size.",
              "R/F to increase/decrease brush density."] if drawMode else
              ["Centroid Mode",
               "Left click to add a cluster.",
               "Right click to remove nearest cluster.",
               "C to change the color of the nearest centroid."]
              ]

    statusText = ["Trails : on" if trails else "Trails : off",
                  "Draw mode : on" if drawMode else "Draw mode : off",
                  f"Brush size : {Rad} | Brush density : {brushDen}",
                  f"Steps in total : {stepsT}",
                  f"Steps in this iteration : {steps}",
                  f"Number of points : {dSize}",
                  f"Number of clusters : {noK}"]

    count = 0
    for box in UItext:
        for lines in box:
            text = font.render(lines, True, (255,255,255))
            surface.blit(text, (resX + 10, t+s*count))
            count += 1

    count = 0
    for lines in statusText:
        text = font.render(lines, True, (255, 255, 255))
        surface.blit(text, (resX + 10, resY-s*count))
        count += 1

    pygame.display.flip()
